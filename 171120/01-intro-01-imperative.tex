\section{Парадигмы}
\subsection{Что такое}

\begin{frame}
	\tableofcontents[currentsection,currentsubsection]
\end{frame}

\begin{frame}
	\begin{exampleblock}{}
		\large
		\vskip5mm
		Программирование "--- это управление абстракциями.
	\end{exampleblock}
	\begin{itemize}
		\item На уровне <<железа>> даже для отображения простой веб-страницы надо сделать очень много.
		\item Написать код сразу на уровне <<железа>> нереально.
		\item К тому же будет жёстко привязано к <<железу>>.
		\item В программировании постоянно абстрагируются от неважных деталей:
			\begin{itemize}
				\item На каком железе запущена программа "--- стандартные библиотеки.
				\item Как выглядят и комбинируются стандартные конструкции "--- язык программирования.
				\item Как реализован кусок внутри программы "--- функции, объекты.
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\begin{itemize}
		\item Абстракции можно выставлять разные.
		\item Парадигма программирования "--- это идея о том, как можно выстраивать абстракции.
		\item Парадигмы бывают разные: императивное программирование, декларативное, функциональное.
		\item Друг друга не взаимоисключают.
		\item Можно вводить более тонкое деление.
		\item Можно назвать <<стилем>> написания программ.
		\item Абстракции можно строить и на неподходящем языке (на C можно писать в функциональном стиле), но будет неудобно.
		\item Часто языки поддерживают некоторую смесь парадигм.
	\end{itemize}
\end{frame}

\subsection{Императивное программирование}
\begin{frame}{Императивное программирование}
	\begin{exampleblock}{Определение}
		Алгоритм "--- набор инструкций, описывающих порядок действий исполнителя для достижения некоторого результата
	\end{exampleblock}
	\begin{itemize}
		\item В императивном стиле код программы описывает \textit{как} надо достигать результата.
		\item Есть постоянно изменяющееся состояние программы (например, переменные).
		\item Хорошо ложится на <<железо>>: оно действительно меняет состояние памяти.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Пример-1}
\begin{minted}{asm}
	mov $2, %eax
	add $3, %eax
	mov $4, %ebx
	add $5, %ebx
	add %eax, %ebx
	mov %ebx, x
\end{minted}
	\begin{itemize}
		\item При вычислении арифметических выражений обычно такая точность не требуется, получаем абстракцию:
\begin{minted}{cpp}
x = (2 + 3) + (4 + 5);
\end{minted}
		\item Новая абстракция позволила записать то же самое намного короче и читаемее.
		\item При этом мы несколько пожертвовали контролем за низким уровнем "--- доверились компилятору/оптимизатору.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Пример-2}
\begin{minted}{basic}
100 IF x <> 20 THEN GOTO 200
150 PRINT "x is 20"
190 GOTO 300
200 IF x <> 10 THEN GOTO 270
220 PRINT "x is 10"
250 GOTO 300
270 PRINT "x is neither 10, nor 20"
300 PRINT "Done"
\end{minted}
	\begin{itemize}
		\item Выше "--- пример императивного кода на языке BASIC.
		\item Я не уверен, что написал его правильно. Что он делает?\pause
		\item
\begin{minted}{cpp}
if (x == 20) printf("x is 20\n");
else if (x == 10) printf("x is 10\n");
else printf("x is neither 10, nor 20\n");
\end{minted}
		\item А если бы было больше if'ов?
	\end{itemize}
\end{frame}

\begin{frame}[t]{Структурное программирование}
	\begin{itemize}
		\item Решение: вводим в язык конструкции \t{if}, \t{else}, \t{for} и прочие, \textit{с явно выделенными блоками кода}.
		\item Эти конструкции структурируют программу и выделяют, как может пойти исполнение.
		\item Морально запрещаем себе пользоваться \t{goto}, чтобы не скатиться обратно.
		\item Первые компьютеры появились в конце 1940-х.
		\item Поддержка структурного программирования в языках появилась в\only<1>{...}\only<2->{ конце 1950-х (ALGOL).}
		\only<2->{
		\item В 1966 году доказана теорема Бёма-Якопини: любой алгоритм можно записать при помощи \t{if} и циклов.
		\item В 1968 году опубликовано письмо Дейкстры (того самого) <<О вреде оператора \t{goto}>>.
		}
	\end{itemize}
\end{frame}

\begin{frame}
	Плюсы:
	\begin{itemize}
		\item Не слишком оторвано от железа.
		\item Если не брезговать отступами, то легко видно, как пойдёт выполнение программы.
		\item Не требует сложных вычислений для компиляции.
	\end{itemize}
	Минусы:
	\begin{itemize}
		\item Всё ещё сложно доказывать корректность.
		\item Можно (и нужно!) вводить \textit{контракты} функций и \textit{инварианты} для циклов.
		\item Частенько этим пренебрегают: надо хорошо угадать место, где поставить инвариант, чтобы было попроще доказывать корректность.
		\item Может быть глобальное состояние "--- его тоже надо включать в контракт/инвариант.
		\item Протестировать одну итерацию цикла в отрыве от цикла нельзя.
	\end{itemize}
\end{frame}

\begin{frame}{Как бороться}
	\begin{exampleblock}{}
		\large
		\vskip5mm
		Программирование "--- это искусство не ошибаться на единицу.
	\end{exampleblock}
	\begin{itemize}
		\item Добавлять $\pm 1$ в случайные места кода, чтобы сошлось на примерах (не надо так).
		\item А потом спутники падают и хакеры \href{http://www.cvedetails.com/cve/cve-2014-7187}{могут уронить сервер через \t{bash}}.
		\item Явно писать инварианты для двоичного поиска, разделения массива в quick sort, объединения массивов в merge sort...
		\item Запускать статические анализаторы (вроде \t{-Wall -Wextra}).
		\item Ставить \t{assert}'ы для проверок инвариантов.
		\item Использовать формальные системы доказательств (надо размечать код).
	\end{itemize}
\end{frame}
