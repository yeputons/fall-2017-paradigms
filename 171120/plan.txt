== Парадигмы и императивное программирование ==
Программирование - это управление абстракциями.
Парадигма - это. Примеры (ООП, императивное, событийное, обобщённое). Они не взаимоисключают и могут описывать разные уровни абстракций.
Алгоритм - последовательность шагов (школа). Это императивное (империо, указания). Есть изменяющееся состояние. Хорошо: процессоры так и работают, принципиально другого не было собрано (проверить), люди тоже обычно следуют инструкциям и выполняют команду за раз.
Плохо: сложно доказывать корректность. Можно и нужно вводить контракты функций, но они бывают сложные (из-за побочных эффектов и влияния глобального состояния) и нельзя доказывать циклы. Нужны инварианты, но их в лучшем случае пишут в комментариях и проверяют assert'ами в процессе выполнения. Не протестировать отдельную итерацию цикла на халяву. Про инварианты сложнее говорить, когда они неявные, надо ещё понимать, где они возникают (между x++ и y++ ставить инвариант бессмысленно).

Примеры: бинпоиск, partition в qsort, "искусство не ошибаться на единицу и в знаках", многопоточность.
Хотя есть компиляторы с системой типов, thread annots, системы доказательств.

== Декларативное и функциональное ==
Декларативное: мы говорим _что_ хотим получить, компилятор сам пишет код.
Например: SQL, list comprehension, DSL для парсеров-грамматик, "напиши сообщение серверу туда-то".
Можно и в императивном ввести функций, тут скорее идея, чем строго определение. Просто высокий уровень абстракции, _которого хватает для всех целей_.

ФП: алгоритм больше не последовательность шагов, а математическая функция с входом и выходом, как на контестах. Никаких побочных эффектов в "чистом" варианте. Это основное свойство, которое тащит все остальные. Как вычисляется - никто не гарантирует, да это и не важно (по модулю используемого времени/памяти при трансляции в ассемблер). В теории хорошо параллелить (нет состояния), но сложно делать ввод-вывод (надо "загрязнять" язык, на этом занятии hello world сделаем, но не поймём).

== Haskell ==
Открыть блокнот для записей и настроить запуск ghci командами :load и :reload и :r. Посчитать числа и удолбаться об отрицательные (потому что закостылено, единственный унарный оператор).
Статическая типизация: == работают только на одном типе. Вызов функций без скобочек и со скобочками вокруг каждого аргумента (когда надо?).
Показать функции (+) и (*), а также div и mod.
Переменных нет, списки односвязные и гомогенные, массивов нет.
Показать, что == работает разумно на списках, если может. Не компилируется, если не может (стаитические типы). Есть математическое не равно: /=.
Функции head, tail, take, drop (дома напишите).
Квадратные скобки в списках - синтаксический сахар.
Строк нет - это синтаксический сахар для [Char].
Есть tuple, zip, [2..4] и даже ['A'..'Z'], последний можно определять для своих.
Анонс бесконечных списков.

Показать list comprehension с guard'ами для поиска чисел, чья сумма ровно 10.
Упражнение: Как найти Пифагоровы тройки?
Комментарии: -- и {--}.
Синтаксис для определения функций: пример с оператором "и" и "или", пример с суммой чисел.

Псевдо-упражнение: как посчитать сумму чисел в массиве, если циклов нет? Есть функция sum :) Нормальное решение позже.
Псевдо-упражнение: как посчитать сумму квадратов чисел? Определить функцию для квадрата (лямбдой), а потом map.
Упражнение: придумайте ещё какое-нибудь приобразование списка, в котором нужен цикл for. Получится только если элементы как-то друг на друга влияют.
Например, это на самом деле символы строки и надо разбить по пробелам.
Тогда это хорошо бы разделить на несколько этапов: сначала преобразование в смысловые элементы (где будет сложный цикл), а потом - простые.
Сложность изолирована; можно тестировать по отдельности.

== Haskell честный ==

Теперь честно:
Пример с факториалом, показывается рекурсия и кусок pattern matching. . 
Упражнения для переписывания с C++ на Haskell: возведение двойки в степень, числа Фибоначчи.
Увидели pattern matching.
Функции должны начинаться с маленькой буквы, можно использовать апостроф в названии.
Показать if и guards в качестве альтернативы.

Как теперь написать функцию sum? Показать функциональное решение.
Показать _ и скобочки вокруг аргументов в pattern matching.
Показать неявное состояние в императивной программе
Показать where.

Упражнение для переписывания с Python на Haskell: удаление подряд идущих дубликатов.
Потом написать в функциональном стиле.
Найти ошибку в применении перестановки к массиву (в перестановке элементы могут повторяться) в императивном стиле in-place. Не получится.
Написать функциональное.

Замечания: мы задолбаемся делать что-то по индексам или протаскивать зависимости, поэтому придётся думать, как без них. Это так и надо, это хорошо.

Шутка из твиттера про хаскель/коргель/пудель.

== Ещё про ФП ==
Форсирует писать инварианты.
По минимуму используются управляющие конструкции в угоду pattern matching на верхнем уровне, если нужна - обычно выносят в функцию.
Обычно код короче, сильно компактнее, проще доказывается (меньше багов). Сложнее написать код, в котором есть скрытое предположение или скрытый баг.
Активно используются абстракции из математики (говорят, тут замешана теория категорий). В частности, "моноид" - реально полезная штука (на нём можно написать дерево отрезков).
Что плохо: требуется учиться читать функциональный код и знать названия каких-то конструкций, весь реальный мир - вокруг взаимодействий, мутаций и состояний. Поэтому обычно комбинируют подходы.

TODO ниже
== Больше функций ==

Напоминание: подсчёт суммы в списке.
Ещё пример: конкатенация строк.
Ещё пример: найти максимум в списке.
Ещё пример: найти самое большое число в массиве строчек.
Что общего между этими функциями?
показать foldr. Сказать, что foldr - популярная функция. Обычно нужна она. Зовётся "функция высшего порядка".
Показать foldr (:), показать картинку.
Упражнение: написать all/any через foldr.
Упражнение: написать сумму квадратов чисел.
как выразить map через foldr?
Получаем, что всё есть foldr.

== Статический полиморфизм ==
У нас пока были только типы данных, а типов функций не было. Показать команду :t)
Наберите :t sum' (для списков).
Рассказать про стрелочную нотацию,
Получаем, что sum почти пофиг, с какими списками работать (лишь бы были числом) - это и есть статический полиморфизм.
А map - функция высшего порядка.

Игра "угадай по сигнатуре, что делает функция". Разобрать, что вообще может делать not::Bool->Bool, что вообще может делать [a]->a в чистом языке (возвращать элемент по номеру, номер - функция от длины).

Упражнение с общим выводом типов функций по коду: типы для map, для id, для sumMap.
Полиморфизм очень нужен для функций высших порядков.
Показать hoogle, поиск по типу функции, про статический полиморфизм.


== Ленивцы ==

Ленивость и неленивость вычислений, пример с функциями, почему что-то хорошо (либо не тратим время на вычисления, но храним хвост, либо тратим каждый раз). Ленивость не позволяет работать с вводом-выводом, как исправить - добавить RealWorld.
Бонус: "бесконечные" структуры данных, как итераторы. Можно take на них, например, take 24 [3,5..].
Разобрать пример с Фибоначчи и с iota на бесконечные списки. 
С бесконечными правая свёртка тащит. И может завершиться за конечное время на бесконечных списках (пример с any).

Упражнение: написать ++, сказать, что да, тормозит. А с бесконечными списками работает ли?

== Резюме ==


== Haskell-специфичные грабли ==
Намекнуть про классы типов (чтобы писали Ord=>).
рассказать про fromIntegral/round
Стрелочки в типах функций ассоциативны вправо.
Рассказать, почему с унарным оператором всё плохо: (-5) против ((-)5).

Показать hlint.

== В остальных языках ==

полезные свойства ФП: функции высшего порядка, неизменяемые значения, чистые функции без side effects.

Обычно в ФП очень компактные программы и синтаксический сахар (вата).
Обычно языки поддерживают сильное расширение синтаксиса и синтаксическую сахарную вату.

ФП есть не только в Haskell, бывают плюсы, эрланг, питон, скала, джава. В императивных можно легко писать функционально, если есть синтаксис. Только надо очень осторожно с мутабельностью.

чуть сложнее отлаживать, так как нет "состояния".

== Ссылки ==
https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming
http://learnyouahaskell.com - главы 2, 4-6, есть на русском книга "изучай хаскель во имя добра"
http://camlback.cs.ucla.edu
https://www.inf.ed.ac.uk/teaching/courses/inf1/fp/
https://www.ohaskell.guide/whales-n-turtle.html - забить на модули