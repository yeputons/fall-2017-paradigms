\subsection{Декларативное программирование}

\begin{frame}[fragile]{Декларативное программирование}
	\begin{itemize}
		\item Поднимаемся ещё на ступеньку выше "--- говорим компьютеру, \textit{что} сделать, а не \textit{как}.
		\item Примеры на Python:
\begin{minted}{python}
x, y, z = range(3)
xs = [a ** 2 for a in range(10)]
\end{minted}
		\item Пример на MetaPost:
\begin{minted}{python}
a + b = 3;
2a = b + 3;
show a, b;  % 2 1
\end{minted}
		\item Пример \href{http://codeforces.com/blog/entry/17177}{на Picat}:
\begin{verbatim}
Vals = new_list(N),
Vals :: 1..10000,
prod(Vals) #= sum(Vals) + D,
solve(Vals).
\end{verbatim}
	\end{itemize}
\end{frame}

\begin{frame}{Особенности}
	\begin{itemize}
		\item Компилятор сам сгенерирует код, и сам напишет перебор.
		\item Опять жертвуем точным контролем в угоду удобству и читаемости.
		\item Скорость работы и память оценить нельзя, не зная деталей компилятора.
	\end{itemize}
\end{frame}

\begin{frame}{Резюме}
	\begin{itemize}
		\item Если грубо, то можно считать синтаксическим сахаром в императивных языках.
		\item С другой стороны, этого сахара должно быть настолько много, что можно откинуть прежние конструкции <<как>>.
		\item Популярный подход в DSL (Domain-Specific Languages), которые решают узкий круг задач:
			\begin{itemize}
				\item Makefile (получение файлов при помощи консольных команд).
				\item SQL (запросы к БД).
				\item Грамматики для разбора языков программирования (Bison, Boost.Spirit).
			\end{itemize}
		\item В каком-то смысле сюда подходят HTML и XML.
	\end{itemize}
\end{frame}

\subsection{Функциональное программирование}
\begin{frame}
	\tableofcontents[currentsection,currentsubsection]
\end{frame}

\begin{frame}{Основная идея}
	\begin{exampleblock}{Определение}
		Алгоритм "--- это математическая функция от нескольких аргументов.
	\end{exampleblock}
	\begin{itemize}
		\item Как решение задачи на курсе алгоритмов.
		\item Основное свойство "--- \textit{чистота} функций; результат вычисления зависит только от аргументов функции.
		\item Ни слова про состояние программы или порядок вычислений.
		\item Остальные свойства выводятся из чистоты:
			\begin{itemize}
				\item Порядок вычислений неважен.
				\item Состояние программы не может влиять на работу функций.
				\item Например, функция не может читать из глобальных переменных.
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Побочные эффекты}
	\begin{itemize}
		\item То, что происходит в функции помимо вычисления значения, называется \textit{побочным эффектом}.
		\item Результаты всех функций зависят только от аргументов $\iff$ у функций нет побочных эффектов.
		\item В <<идеально чистых>> языках запрещены не только функции с побочными эффектами, но любые побочные эффекты вообще.
		\item В частности, запрещено иметь изменяемое состояние "--- переменные.
		\item Никаких гонок данных.
		\item Непонятно, как тогда делать ввод-вывод "--- это точно побочный эффект.
		\item Идеально чистые языки бесполезны, все в той или иной степени <<загрязнены>>.
	\end{itemize}
\end{frame}
