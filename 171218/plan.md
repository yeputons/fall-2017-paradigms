Общее про VCS
=============

VCS - система контроля версий (VCS).

Что позволяют делать: есть одна папка, а у неё - куча разных версий
("снимков" (snapshot)/"коммитов" (commit)), причём они как-то связаны.
Вся эта информация вместе хранится в "репозитории".

VCS умеет добавлять новые версии (коммитить), смотреть изменения между версиями,
переключать локальную папку между версиями (полностью или частично), смотреть на
связи между версиями, "склеивать" разные версии автоматически или удобно вручную,
и всё это так, чтобы можно было работать на нескольких компьютерах
и не надо было ничего самостоятельно носить на флешках между компьютерами.
Используются везде.

Это примерно как Dropbox/Яндекс.Диск, только сильно круче: вы самостоятельно
контролируете, что другие видят и в каком виде, а также вся информация хранится
и никуда не теряется.

Они бывают разные (Git, Mercurial, SVN) и даже одна система может совсем
по-разному использоваться: в разных командах - в зависимости от их нужд и
традиций, на разных курсах в универе - в зависимости от предпочтений преподавателя.

Когда полезно лично вам
-----------------------

1. Некоторые предметы (вроде парадигм) требуют, чтобы код лежал в каком-то
   репозитории. Например, на хостинге GitHub или GitLab.
   Некоторые предметы (вроде Java в следующем году) могут выдвигать более
   чёткие требования к тому, что и как структурировано внутри репозитория,
   надо уметь с этим работать.
2. Даже если вам дадут инструцию, вы можете удовлетворить формальным
   требованиям, но работать будет неудобно. А можно сделать так, чтобы было
   удобно в тех рамках, что вам дали.
3. Если работаете над вообще своим кодом и используете VCS, то:
   1. Если храните код на GitHub - можно просто показывать преподавателям,
      друзьям, и это такая "резервная копия".
   2. Если вы часто делаете коммиты, то всегда можно посмотреть, что изменилось
      "с последней рабочей версии".
      Пример: у меня в курсе по БД 1200 строк в десятке файлов,
      в проекте по Android - 2300 строк и 30 файлов.
      И мне нестрашно что-то менять и экспериментировать - я всегда знаю, 
      что делать.
      https://github.com/yeputons/ofeed
      https://github.com/yeputons/au-db-fall-2017

Общее про системы
=================

0. Полезно как в компаниях при работе, так и в реальной жизни, если вы пишете хоть что-то с временем жизни больше дня.
1. GitHub != Git, так же как gmail != email. GitHub - это лишь хостинг и набор инструментов.
2. Самая модная VCS сейчас - Git, децентрализованная, есть очень много хороших инструментов для неё (тот же GitHub), не самая простая в освоении, но мощная.
3. VCS используются вообще везде в компаниях, с ними чувствуешь себя увереннее.
4. VCS позволяют интегрироваться с кучей полезных инструментов.
5. VCS надо использовать "правильно". Разные "правильно" использовать по-разному, но есть некоторые общие требования. Надо изучать книжки или руководства. Нет "единого правильного подхода". В каждой компании может отличаться. Например, некоторые системы (в том числе Git) плохо подходят, чтобы в них хранить хоть что-то, кроме исходного кода в виде текстов (то есть .doc файлы и прочее - мимо кассы).
6. Инструменты для VCS тоже надо использовать "правильно". Опять же, отличается в разных системах.
7. Из VCS очень сложно удалить информацию. Из централизованной почти никогда нельзя (если вы не админ), из децентрализованной (вроде Git) можно при помощи пары специальных команд, так что если где-то читаете ответ на вопрос "как что-то удалить" - будьте осторожны. Обычно в VCS информация только добавляется.

Общее про Git
=============

Термин: "репозиторий" - это хрень, которая хранит внутри себя кучу версий кода.
Например, лежит на GitHub. Чтобы хоть что-то сделать с репозиторием,
его надо склонировать, получив копию репозитория у себя локально (после этого
то, с чего клонировали, не нужно). Что-то сделали, специальной командой залили
изменения обратно. Или наоборот - получили новые с GitHub.

Вот эта особенность с "клонированием" есть общее свойство "децентрализованных" систем.
Вообще говоря, разные репозитории почти никак не связаны.

Есть консольная утилита, есть GUI. Мы работаем с консолью, потому что все руководства
про неё и все вопросы на StackOverflow про неё.

Термин: "коммит" - это какой-то набор файлов (не папок, они сами вычисляются)
и их содержимого. Коммиты хранятся в виде графа.
Обычно мы начинаем с "Initial commit", в котором добавляется какая-нибудь очень
простая заглушка, а потом начинает делать по коммиту на каждое разумное изменение.
Например: если оно скомпилилось и заработало - это повод сделать коммит,
чтобы запомнить рабочую версию.
После этого создаётся новый коммит со стрелочкой на то, из чего создали (родительский коммит).
Также можно написать сообщение (this commit does the following: adds что-то там...).
Сообщения нужны, чтобы искать потом по логам, где что изменилось/поменялось.

Термин: "ветка" - просто указатель на коммит.
Обычно есть ветка с названием "master" - типа "последняя версия", но это не всегда так.
А вот, собственно, то, как связаны репозитории: если я склонировал репозиторий,
то git запоминает, где стоят ветки локально, а где они стояли в удалённом репозитории (remote).
Чтобы не было проблем с нумерацией, коммиты нумеруются хэшами от своего содержимого.

Мораль такая: если вам что-то нужно сделать в git, нарисуйте кружочки (коммиты)
со стрелочками (связи между ними), а также указатели на ветки - текущее состояние.
После этого решите, какие кружочки надо добавить (удалять нельзя) и
как передвинуть указатели на ветки. После этого гуглить, как это сделать.

Что почитать
------------

Источник знаний: книга "Pro Git", бесплатная, open source (https://github.com/progit/progit2).
	Страница на русском: https://git-scm.com/book/ru/v2
Игрушка с визуализацией: http://learngitbranching.js.org/
Онлайн-игрушка на ветки: https://github.com/git-game/git-game
Домашка для 1-2 групп: https://docs.google.com/document/d/1_1ZBC3XEfNAsTmGrZegXivqfTs2_EEj422GeKpbOtP8/edit
https://gitexercises.fracz.com

Ситуация 1
==========

Теория
------
https://github.com/yeputons/spbau-java-course-assignments-term4
https://github.com/yeputons/au-kotlin-fall-2017

У нас есть один репозиторий.
В нём есть один исходный коммит, а дальше от него расходятся коммиты
с описаниями домашек.
1. Форкаем репозиторий, получаем копию на GitHub.
2. Клонируем себе эту штуку с GitHub.
3. Переключаемся в ветку с домашкой, делаем-делаем, иногда пушим к себе в репозиторий
   (итого получается аж три версии ветки).
4. Когда дописали - запушили в свой репозиторий и пользуемся интерфейсом GitHub,
   чтобы преподавателю было удобно смотреть на изменения (pull request).

Практика
--------

Кому скучно - идём и разбираемся с 

0. Настройка `git config --global` user.email, user.name, editor.


1. Я создаю репозиторий, как препод. Добавляю туда две "домашки": README и
   файл Hello World на питоне, в который надо что-то дописать
   (в первой домашке - в два захода в один файл, во второй
   домашке - в несколько файлов).
2. Студенты форкают, клонируют локально.
3. Когда вы склонировали, у вас локально в папке есть две вещи:
   1. `.git` - собственно, репозиторий, руками туда почти никогда не надо лазить
      (кроме как `.git/config` посмотреть)
   2. Все остальное - это текущая рабочая директория (Working Dir).
      В ней вы работаете с файлами как хотите, репозиторий это не меняет.
      В каждый момент есть `HEAD` - указатель на коммит, из которого получена
      Working Dir. Он обычно 'attached' (привязан) к какой-то ветке, например,
      `master`, давайте посмотрим `git status`.
3б. `git checkout` - переключились в ветку (изменили HEAD), working dir целиком поменялась.
4. Поменяйте файл. Напишите `git status`, чтобы увидеть, что произошло.
5. Каждый файл в рабочей папке может быть либо tracked (отслеживаемый), либо untracked.
   Отличаются только тем, что за изменениями в tracked git следит.
6. Напишем `git diff`, чтобы посмотреть изменения в tracked файлах.
7. Создадим левый файл, снова напишем `git diff` (и этот файл уже untracked).
8. Помимо рабочей папки есть так называемый индекс (index) или staging area:
   https://stackoverflow.com/a/3690796/767632
   Это (почти) невидимое состояние следующего коммита. Исходно оно совпадает с
   тем, из чего мы построили папку.
9. Напишем `git add foo.txt` - это целиком добавит файл в staged.
10. `git status` (как обычно), `git diff --staged` (`--cached`) - сравнили с исходным коммитом,
    `git diff` - сравнили staged с working directory.
11. Если сейчас поменять файл - изменится только working directory, но не staged.
12. Сделали ещё раз `git status`, откатили изменения до staged при помощи `git checkout`
    (да, второй смысл).
13. `git commit`, ввели сообщение. Теперь поменялся HEAD.
14. Посмотрим `git log`.
15. Давайте теперь изменим вторую часть файла. Снова статус, изменение, статус, коммит.
15. Теперь `git push` - загрузить изменения в свой репозиторий.
16. Зашли на GitHub, потыкались по Branches, history, diff'ам.
17. Создали Pull Request из одной ветки в другую.

А теперь я добавляю новую домашку (вернуть из функции среднее арифметическое,
куча функций, куча кода)
и рисую на доске, что получилось.
1. `git remote add upstream ...`
2. `git fetch upstream`
3. `git checkout upstream/task-03` - создалась локальная ветка с таким же названием.
4. Ура, теперь можем с ней делать то же, что обычно, а потом сделать `push`.
5. Сделали pull request.
6. Я добавляю в домашку немного кода (ещё один тест). А PR умный - показывает только
   ваши изменения.
7. `git fetch upstream`, `git log --...`, `git diff`, `git diff ...`, `git diff ..`.
8. Не надо переносить изменения руками: `git merge upstream/master`, создался коммит.

Пусть вы захотели поэкспериментировать.
Тогда создаёте новую ветку `git checkout -b новаяветка` (создаётся из текущего
коммита), `HEAD` переключается, новые коммиты будут двигать `новаяветка`.
Преподу не видно, а у вас всё видно.

Например, у меня в БД (да и в компиляторах) есть основная ветка для показа преподу, а если я не уверен,
что затея обернётся успехом (миграция на `add-cpp11`) - я делаю это в отдельной
ветке, чтобы было просто переключить. Если успех - переключаюсь обратно.
Если делаю несколько домашек друг на друге - то базирую ветки друг на друге
(тут намёк про rebase).
https://github.com/yeputons/au-compilers-fall-2016

А где-то требуют pull request в свой `master`, а `master` не трогать.

Например, давайте так сделаем в нашей третьей учебной git-домашке.
Сделали, сделали `merge`, но случился fast-forward.

Пример с заначкой:
1. Создали ветку, написали хрень.
2. Коммитить в ветку не хотим, потому что хрень. `git stash` (сохраняет изменения
   между working dir и HEAD в заначку).
3. Проверили, что хотели.
4. `git list stash`, `git show stash@{0}`, `git stash pop` (достаёт, но в staged).

Ситуация 2
==========

Мы делаем проект с кем-то.
Тогда есть одна основная ветка. Два варианта работы:
1. Большая фича - новая ветка, потом мёржить. Так обычно в командах. И можно заодно pull request для ревью.
2. Делаем небольшие изменения прямо в master, при этом merge --rebase, чтобы история была нормальная.

Практика
--------

1. Создаю новый репозиторий для демонстраций: в нём несколько коммитов.
2. Создаю два клона.
3. В первом клоне добавляю один файл, `git push`.
4. Во втором - другой, `git push`, упс.
5. `git fetch`, изучаем логи, `git merge --rebase` (ещё можно сразу `pull --rebase`), изучаем логи `git push`.
6. В первом изменяем один файл, `git push`.
7. Во втором меняем его же, `git merge --rebase`, упс, конфликт, разрешаем.

Ещё намекнуть про:  interactive rebase, `add -p`, `stash -p`, `git blame`, `git bisect`.
