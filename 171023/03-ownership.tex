\section{Владение ресурсами}

\begin{frame}
	\tableofcontents[currentsection]
\end{frame}

\begin{frame}[t]{Что такое <<ресурс>>?}
	\begin{itemize}
		\item Программы управляют большим количеством \textit{ресурсов}:
			\begin{itemize}
				\item Динамически выделяемая память
				\item Открытые файлы
				\item Сетевые соединения
				\item Общение с какой-нибудь простой железкой (сканер штрих-кодов)
			\end{itemize}
		\item Обычно у \textit{ресурсов} есть следующие свойства:
			\begin{itemize}
				\item К нему можно обращаться по некоторому адресу, указателю, номеру, handle.
				\item
					Этот handle можно получить из функции \textit{открытии} ресурса.
				\item
					Если открываем ресурс несколько раз "--- получаем либо ошибку,
					либо каждый раз новый handle, либо вообще разные ресурсы.
				\item
					Handle обязательно надо \textit{закрыть}, когда ресурс больше не нужен, причём ровно один раз.
				\item
					Один handle предназначен для выполнения \textit{последовательных операций}.
					Обычно он хранит внутри себя какую-то информацию про предыдущие операции
					(например, позицию в файле).
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[t]{Проблемы с ресурсами}
	\begin{itemize}
		\item Все следующие ситуации являются проблемными:
			\begin{itemize}
				\item Handle не закрыли (утечка памяти/ресурсов).
				\item Handle закрыли дважды (неопределённое поведение).
				\item Ресурс используют для двух независимых цепочек операций (они смешиваются, получается чушь).
				\item Ресурс используют после закрытия handle.
			\end{itemize}
		\item Примеры того, за чем надо следить:
			\begin{itemize}
				\item
					Выделенная при помощи \t{malloc}/\t{new}/\t{new[]} память
					освобождается ровно один раз при помощи \t{free}/\t{delete}/\t{delete[]}.
				\item
					Память освобождается тем же методом, что и создавалась.
				\item
					Открытый файл закрывается ровно один раз.
				\item
					Любой созданный поток либо переводится в detached-режим, либо на нём ровно один раз вызывают \t{pthread\_join}.
				\item
					Два потока не пытаются читать из одного файла.
				\item
					Два потока не пытаются одновременно читать и писать в одну переменную.
			\end{itemize}
		\item Это всё дополнительные инварианты.
	\end{itemize}
\end{frame}

\begin{frame}[t]{Концепция <<владения>>}
	\begin{itemize}
		\item Инвариант:
			\begin{itemize}
				\item
					У любого ресурса в любой момент времени в любой точке программы есть ровно один <<владелец>>
					(поток, функция, кусок кода "--- разные уровни детализации).
				\item Только владелец может закрыть ресурс и он обязан это сделать ровно так, как требует ресурс.
				\item Только владелец имеет доступ к ресурсу (но иногда эта часть ослабляется).
			\end{itemize}
		\item Как ведёт себя владение:
			\begin{itemize}
				\item При создании объекта его владельцем становится создатель.
				\item Текущий владелец может явно передать владение другому месту программы.
				\item Объект можно скопировать, тогда получится две копии, у каждой "--- свой владелец.
				\item Объект можно временно <<одолжить>> кому-нибудь: он сможет с ним работать и передавать дальше, но не сможет закрыть.
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Пример}
	Немного упрощая:
\begin{minted}{cpp}
int main() {
  string x = "xxx"; // 1. main() владеет x.
  string res = foo(x);
  // 6. main() получил res во владение от foo().
  // 7. main() удаляет x и res, как владелец.
}
string foo(string &s) {
  // 3. foo() "одолжило" s по ссылке.
  string res = s + "foo";  // 4. foo() создал res.
  return res;  // 5. foo() передал владение res вызвавшему.
}
\end{minted}
\end{frame}

\begin{frame}[t,fragile]{Плохой пример}
\begin{minted}{cpp}
int main() {
  char *s = malloc(2);  // 1. main() владеет s.
  s[0] = 'x'; s[1] = 0;
  s = foo(s);
  // 5. Результат foo() лежит в s, во владении у main()
  free(s);  // 6. Освободили результат foo().
  // 7. А старое s уже потеряно - утечка. Мы его передали
  //    foo(), а foo() не в курсе.
}
char* foo(const char *s) {
  // 2. foo лишь "одалживает" s и только из него читает.
  char* res = malloc(strlen(s) + 1);  // 3. Владеем res.
  strcpy(res, s);
  return res;  // 4. Передаём res во владение вызвавшему.
}
\end{minted}
\end{frame}

\begin{frame}[t]{Последствия}
	\begin{itemize}
		\item С такими инвариантами упрощаются проблемы с освобождением, race condition и остальным.
		\item В некоторых языках есть разного вида конструкции, которые форсируют этот инвариант:
			\begin{itemize}
				\item
					RAII в C++: если объект выделен на стеке, то им владеет текущая функция.
					Отсюда растут <<умные указатели>>.
				\item
					Обычно в C++ никогда напрямую не используются операции <<открыть ресурс>>
					или <<закрыть ресурс>> "--- всё через RAII (\t{ifstream} вместо \t{FILE*}, скажем).
				\item
					Язык Rust: в синтаксисе надо явно указывать, кто чем владеет и как передаёт.
			\end{itemize} 
		\item
			Концепция имеет смысл даже в языках со сборкой мусора (Python, Java, JavaScript):
			там мы всё равно должны закрывать файлы и всё ещё есть race conditions.
	\end{itemize}
\end{frame}

\begin{frame}[t]{Примеры ресурсов}
	\begin{itemize}
		\item Динамическая память
		\item Мьютексы pthread (надо создавать и уничтожать)
		\item Потоки (надо либо join, либо передавать владение ОС при помощи detach)
		\item \t{FILE*} (закрываем руками), \t{ifstream} (компилятор C++ всегда закрывает за нас)
		\item Стандартные потоки ввода и вывода
		\item Переменные (впрочем, с локальными всё просто)
	\end{itemize}
\end{frame}

\begin{frame}[t]{Практический вывод}
	\begin{itemize}
		\item
			У всех параметров и возвращаемых значений всегда указывайте, кто и когда чем владеет.
			Особенно в многопоточных приложениях.
		\item Владение "--- это свойство \textit{вызываемой} функции.
		\item Как закрывать ресурс "--- это свойство \textit{ресурса} (например, разные указатели может быть надо закрыть по-разному).
		\item Параметр можно либо временно одолжить, либо передать во владение.
		\item Возвращаемое значение либо передаётся вызываемой функции, либо ей одалживается на время.
		\item Если нам что-то одолжили, мы не имеем права это удалять или куда-то сохранять (потому что нам одолжили лишь временно).
	\end{itemize}
\end{frame}
