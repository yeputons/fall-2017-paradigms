\subsection{Прочие плюшки}
\begin{frame}[fragile]{Стандартные классы}
	\begin{itemize}
		\item \t{Show} "--- то, что можно вывести на экран.
		\item \t{Eq} "--- операторы \t{==} и \t{/=}.
		\item \t{Ord} "--- операторы \t{<}, \t{<=} и прочие.
		\item \t{Functor} "--- структура данных, на которой есть \t{map}.
		\item \t{Foldable} "--- структура данных, на которой есть \t{foldr} (по сути, умеет разворачиваться в список).
		\item Для первых трёх Haskell умеет сам генерировать адекватные реализации, если попросить:
\begin{minted}{haskell}
data List a = Empty | Cons a (List a)
            deriving (Show, Eq, Ord)
\end{minted}
		\item Порядок <<лексикографический>> (более ранний конструктор меньше).
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Автовывод контекста}
\begin{minted}{haskell}
-- Ord a => a -> a -> a
max' a b = if a > b then a else b
-- Eq, кстати, тоже будет:
-- class Eq a => Ord a where
-- ...

-- (Functor f, Eq a) => a -> f a -> f (Maybe a)
removeByValue x ys = fmap f ys
  where
    f y | x == y    = Nothing
        | otherwise = Just y
\end{minted}
	Если в файле не видно разных функций с одинаковым названием из разных классов, то компилятор может автоматически вывести ограничения на типы (контекст).
\end{frame}

\begin{frame}[fragile]{Резюме}
	\begin{itemize}
		\item Альтернатива классам типов "--- интерфейсы из ООП или перегрузки функций.
		\item Перегрузки функций не отражают связи между разными функциями (вроде \t{==} и \t{/=}).
		\item Интерфейсы из ООП \textit{обычно} надо определять в момент создания каждого типа (не добавить интерфейс к уже существующему).
		\item Интерфейсы из ООП \textit{обычно} не позволяют делать реализации по умолчанию "--- надо писать руками.
		\item Классы типов всё это позволяют.
		\item Компилятор умеет автоматически выводить нужный контекст.
		\item В Haskell классов типов используется везде, где есть хотя бы доля обобщаемости.
	\end{itemize}
\end{frame}
