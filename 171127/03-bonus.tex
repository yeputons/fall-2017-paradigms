\section{Бонус}

\begin{frame}
	\tableofcontents[currentsection,currentsubsection]
\end{frame}

\begin{frame}[fragile]{Ввод-вывод}
	\textbf{В домашке не потребуется}
\begin{minted}{haskell}
solve :: Int -> Int
solve = (+1)
mainPure :: [String] -> [String]
mainPure = map (show . solve . (read :: String -> Int))
main = interact (unlines . mainPure . lines)
\end{minted}
	\begin{itemize}
		\item Функции \t{main} и \t{interact} "--- пока что магия
		\item Функция \t{show} преобразует почти любое значение в строчку
		\item Функция \t{read}, если явно указать её тип, преобразует строчку в значение
		\item Всё работает лениво и интерактивно
	\end{itemize}
\end{frame}

\begin{frame}{Особенности функционального стиля}
	Необязательно, но обычно:
	\begin{itemize}
		\item Алгоритм разбивается не на <<шаги>>, а на мелкие функции с чёткими контрактами
		\item Вместо циклов "--- рекурсия или встроенные функции (коих много)
		\item Очень мощная система типов:
			\begin{itemize}
				\item Функции обощаются получше
				\item Алгебраические типы данных, позволяют писать \textit{везде определённые} функции
				\item Вместо \t{if} "--- \textit{pattern matching}
			\end{itemize}
		\item Очень компактный код
		\item Нет никаких изменяемых переменных, захотели изменить объект "--- создали копию (\textit{иммутабельность})
		\item Частичное применение функций (или каррирование, из одного другое в каком-то смысле следует)
	\end{itemize}
\end{frame}

\begin{frame}{Мои наблюдения-1}
	\begin{itemize}
		\item На функциональных языках обычно очень компактные программы и много синтаксического сахара.
		\item Обычно функциональные языки (в том числе Haskell) умеют очень сильно расширять свой синтаксис до неузнаваемости.
		\item Иногда всё это превращается в сахарную вату.
		\item Элементы ФП в разной степени поддерживаются в разных языках, в том числе в
			<<императивных>>: C++, Python, Java.
		\item Есть модные смеси императивного и функционального программирования вроде Scala или OCaml.
		\item Некоторые функциональные языки используются в реальной жизни: Erlang.
		\item Чисто функциональные программы может быть сложнее отлаживать, так как нет <<состояния программы>>.
	\end{itemize}
\end{frame}

\begin{frame}{Мои наблюдения-2}
	\begin{itemize}
		\item Многие идеи из ФП полезны и в повседневной жизни:
			\begin{itemize}
				\item Неизменяемое состояние.
				\item Функции высшего порядка (где есть поддержка в языке).
				\item Чистые функции без побочных эффектов.
			\end{itemize}
		\item Если язык поддерживают хотя бы \t{map}, лямбда-функции или list comprehension,
			на нём уже намного приятнее писать.
		\item Функциональные элементы могут сильно упростить код императивной программы без потери скорости.
		\item Дополнительных проблем эти элементы не вносят.
		\item Надо быть аккуратными и не мешать их с изменяемым состоянием.
	\end{itemize}
\end{frame}
