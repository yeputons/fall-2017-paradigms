\section{Основы основ}
\subsection{Текстовые файлы, БД и СУБД}

\begin{frame}
	\tableofcontents[currentsection,currentsubsection]
\end{frame}

\begin{frame}{Постановка задачи}
	\begin{itemize}
		\item Пусть мы пишем приложения для учёта товаров в магазине.
		\item Надо знать:
			\begin{enumerate}
				\item Какой товар есть на складе и витринах.
				\item Где он лежит.
				\item По какой цене товар закуплен (могут быть разные партии).
				\item По какой цене товар сейчас продаётся.
				\item Какие покупки были сделаны (что куплено вместе, на какую сумму, в какое время).
			\end{enumerate}
		\item Возможные события:
			\begin{enumerate}
				\item Приехала поставка со склада.
				\item Касса пробила чек "--- совершена покупка.
			\end{enumerate}
		\item Надо, чтобы приложение сохраняло состояние между перезапусками.
		\item Вопрос: как это сделать?
	\end{itemize}
\end{frame}

\begin{frame}{Вариант с файлами}
	\begin{itemize}
		\item Создаём кучу внутренних структур для хранения объектов.
		\item При выходе из приложения пишем их в каком-то формате не диск, при запуске "--- считываем.
	\end{itemize}
	Проблемы:\pause
	\begin{itemize}
		\item На запуск и выход требуется существенное время (записать много данных).
		\item Если пропало питание, мы потеряли данные.
	\end{itemize}
	Решения:\pause
	\begin{itemize}
		\item Меняем формат файла, чтобы можно было обновлять только изменившиеся кусочки.
		\item Храним структуры и объекты в разных маленьких файлах, чтобы изменения обрабатывала файловая система, а не мы.
	\end{itemize}
\end{frame}

\begin{frame}[t]{Усложнение}
	\begin{itemize}
		\item А теперь у нас десять касс и два компьютера в разных концах склада.
		\item Одной программы теперь недостаточно, надо несколько.
	\end{itemize}
	\only<2-7>{
	Возможные решения:
	\begin{enumerate}
		\only<2-3>{
		\setcounter{enumi}{0}
		\item Каждая хранит данные независимо, а после закрытия мы склеиваем данные вместе:
			\only<3>{
			\begin{itemize}
				\item Несложно пишется и сложно вызвать цепную реакцию из ошибок "--- ломается только в момент склейки.
				\item Так раньше работали банки (<<ваш перевод будет обработан в течение $X$ дней>>).
				\item Нет доступа к данным в реальном времени.
			\end{itemize}
			}
		}
		\only<4-5>{
		\setcounter{enumi}{1}
		\item Дать общий доступ ко всем файлам со всех компьютеров:
			\only<5>{
			\begin{itemize}
				\item Появляется конкуренция за доступ и race condition: нельзя, чтобы две программы одновременно работали с одним файлом.
				\item Если изменение затрагивает несколько файлов, то надо их все захватывать; не все сетевые ФС так умеют.
			\end{itemize}
			}
		}
		\only<6-7>{
		\setcounter{enumi}{2}
		\item Написать программу-сервер, которая как-то хранит данные на одном компьютере и обрабатывает сетевые запросы от клиентов:
			\only<7>{
			\begin{itemize}
				\item Получили абстракцию <<хранилище данных>>.
				\item Хранилище инкапсулирует то, как именно данные хранятся (хоть в памяти, хоть на десяти серверах распределённо).
			\end{itemize}
			}
		}
	\end{enumerate}
	}
	\only<8-9>{
	Общие проблемы:
	\only<9>{
	\begin{itemize}
		\item Хранилище сильно завязано на то, какие именно данные оно хранит: формат хранения на диске, протокол, внутренние структуры...
		\item Не очень много кода в хранилище действительно хочет знать о структуре данных что-то подробнее <<число или строка>>.
		\item Для любого взаимодействия с хранилищем требуется писать своё новое приложение с поддержкой протокола.
	\end{itemize}
	}
	}
\end{frame}

\begin{frame}[t]{СУБД}
	\begin{itemize}
		\item \textit{Система управления базами данных} (СУБД) "--- это сервис, который умеет хранить данные \textit{произвольной структуры}
			(в определённых рамках, конечно, не совсем бессистемные).
		\item \textit{База данных} "--- это описание данных \textbf{и их структуры}, которые хранятся в СУБД.
		\item СУБД обычно делят на два вида в зависимости от того, как они структурируют данные: реляционные (relational) и нереляционные (non-relational или NoSQL).
		\item Реляционные "--- это классика (существуют с 80-х годов), их и будем изучать.
		\item Нереляционные примерно того же возраста, но вошли в тренд только в последние лет десять.
		\item Примеры реляционных: MySQL, MariaDB, Oracle, MS SQL, Sqlite.
		\item Примеры нереляционных: MongoDB, Redis, Memcached, Cassandra.
	\end{itemize}
\end{frame}
