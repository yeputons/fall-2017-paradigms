\subsection{ДЗ и простой SQL}

\begin{frame}{Типы данных}
	Смотрим на таблицу \t{Country}:
	\begin{itemize}
		\item \t{INTEGER} "--- целое число (размер варьируется от СУБД к СУБД, как и название).
		\item \t{REAL} "--- вещественное число с плавающей запятой.
		\item \t{VARCHAR(45)} "--- строка произвольной длины, но не длиннее 45 символов\footnote{А сколько символов занимает буква <<ш>>? А в какой кодировке?}.
			Если не влезает "--- поведение зависит от СУБД.
	\end{itemize}
	Вообще говоря, конкретно в SQLite значения в столбце могут иметь тип, не совпадающий со столбцом, но об этом лучше не думать.

	За кадром остались типы:
	\begin{itemize}
		\item \t{BLOB} "--- бинарные данные любой длины.
		\item \t{TEXT} "--- строка произвольной длины без ограничений.
		\item \t{CHAR(10)} "--- строка фиксированной длины (может работать быстрее).
	\end{itemize}
\end{frame}

\begin{frame}{Прочие типы данных}
	В каждой СУБД свои типы, они могут отличаться по поведению даже просто при разных настройках внутри одной базы данных.
	Но обычно они называются приблизительно так:

	\begin{itemize}
		\item \t{DECIMAL(10, 5)} "--- вещественное число с фиксированной запятой.
		\item Вариации на тему целых чисел: \t{SMALLINT}, \t{MEDIUMINT}, ...
		\item \t{FLOAT} "--- альтернатива \t{DOUBLE}.
		\item \t{DATE}, \t{TIME}, \t{DATETIME}, \t{TIMESTAMP} и вариации для хранения дат
			\footnote{Правильная работа с датами "--- тема отдельной лекции: \href{https://habrahabr.ru/post/146109/}{1}, \href{https://habrahabr.ru/company/mailru/blog/242645/}{2}}.
	\end{itemize}

	Мораль двух слайдов: сразу сказать, какой тип <<правильный>> в конкретной ситуации нельзя,
	надо хорошо понимать предметную область и СУБД, с которой вы работаете.
	Но для своих проектов по умолчанию можно ограничиться теми типам, что проще называются (предыдущий слайд).
\end{frame}

\begin{frame}{Демонстрация SQL-запросов}
	\begin{itemize}
		\item Запросы отделяются между собой точкой с запятой.
		\item Иногда интерфейс к СУБД не умеет делать несколько запросов одновременно и тогда точка с запятой не нужна.
		\item Комментарии "--- либо два дефиса в начале строки, либо \t{/* ... */}
		\item Результат запроса \t{SELECT} "--- тоже таблица, полученная из исходной.
		\item Наборы строк и столбцов в результате \t{SELECT} могут разительно отличаться от исходной.
		\item Можно фильтровать строки по условиям.
		\item Можно попросить не строки, а какую-то статистику.
		\item Если вы в SQL что-то написали, оно практически всегда либо упадёт при компиляции, либо как-то отработает на любых значениях.
	\end{itemize}
\end{frame}

\begin{frame}[t]{LIMIT и OFFSET}
	\begin{itemize}
		\item Порядок строк в таблицах и результате работы \t{SELECT} не определён.
		\item Но его можно явно задать при помощи \t{ORDER BY}, который сравнивает поля лексикографически в указанном порядке.
		\item
			Важно задавать \t{ORDER BY} так, чтобы он всегда отличал две строки.
			Этого можно добиться, только если мы знаем, какие наборы столбцов всегда отличаются.
		\item
			Другая стандартная проблема: пусть мы подгружаем бесконечную ленту новостей
			запросом \t{LIMIT~10~OFFSET~already\_loaded}.
			\pause
		\item
			Новости в ленте могут добавляться и удаляться, и номера строк даже в идеально отсортированной таблице
			постоянно меняются.
	\end{itemize}
	Мораль: не стоит надеяться на номера строк, \t{LIMIT} и \t{OFFSET} обычно возникают только при выборке <<топ-10>>.

	Правильное решение задачи с лентой:\pause <<верни топ-10 записей после такой-то новости из ленты>>.
\end{frame}

\begin{frame}{DELETE и INSERT}
	Удаление значений:
	\begin{itemize}
		\item \t{DELETE FROM Country} удалит \textbf{все} строки и не почешется.
		\item Надо писать \t{DELETE FROM Country WHERE ...}
		\item По-хорошему перед \t{DELETE} стоит сделать \t{SELECT} и посмотреть.
	\end{itemize}
	Добавление значений:
	\begin{itemize}
		\item
			После слова \t{VALUES} можно написать несколько кортежей со значениями,
			но надо знать точный порядок столбцов в таблице.
		\item На практике столбцы иногда (не часто, но иногда) меняются, добавляются и удаляются,
			поэтому всегда следует писать явно, каким столбцам что соответствует.
		\item При вставке может возникнуть ошибка, если на каком-то столбце были ограничения
	\end{itemize}
\end{frame}

\begin{frame}{Остальные запросы}
	\begin{itemize}
		\item Также бывают запросы \t{CREATE TABLE}, \t{ALTER TABLE}, \t{DROP TABLE} для работы с таблицами.
		\item Несмотря на наличие стандартов языка SQL, каждая база дополняет его по-своему,
			из-за чего получается множество несовместимых диалектов.
		\item Самые базовые команды (только что были) везде работают \textit{примерно} одинаково
			(за исключением неоднозначных ситуаций).
	\end{itemize}
\end{frame}

\begin{frame}{NULL}
	Также есть специальное значение \t{NULL}, которое может лежать в любой колонке, если только на ней нет ограничения \t{NOT NULL}.
	Может обозначать:
	\begin{itemize}
		\item Отсутствие каких-либо данных (неизвестно население страны).
		\item Неопределённый результат вычисления (среднее значение пустого множества, деление на ноль).
		\item Что угодно ещё по желанию программиста.
	\end{itemize}
	Возникающая проблема: нет одного объяснения, как \t{NULL} себя ведёт в разных запросах.
	\begin{itemize}
		\item
			Если считать, что \t{NULL} распространяется как \t{NaN} (Not a Number), т.е. любое вычисление с \t{NULL} даёт \t{NULL},
			то сложно писать запросы в ситуации, где наличие \t{NULL} "--- норма.
		\item
			Если \t{NULL} просто игнорировать, то про него легко забыть (так часто и делают); а он может где-то требовать специальной обработки.
	\end{itemize}
\end{frame}

\begin{frame}{Демонстрация NULL}
    \begin{itemize}
    	\item Разные функции обрабатывает \t{NULL} по-разному, общая цель "--- наиболее консистентное и адекватное поведение.
    	\item Обычно в агрегирующих функциях игнорируется.
    	\item Если вы пишете чуть-чуть несимметричный код (вроде \t{SUM(a) / COUNT(*)}), могут быть последствия.
    	\item Очень легко забыть и получить какой-то правдоподобный, но неверный результат (особенно в соединениях "--- будут дальше).
    \end{itemize}
\end{frame}
