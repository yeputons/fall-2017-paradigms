\subsection{Реляционные СУБД и простой SQL}

\begin{frame}{Реляционные СУБД на практике}
	\begin{itemize}
		\item СУБД хранит одну или несколько независимых БД (баз данных).
		\item Каждая БД "--- это набор таблиц, которые содержат данные.
		\item Таблица имеет фиксированный набор столбцов с названиями и типами.
		\item Фиксированный в каждый момент времени; вообще столбцы можно добавлять, менять, удалять, хоть это и сложные для СУБД операции.
		\item В таблице лежит неупорядоченный набор строк с данными.
		\item На столбцы (или их группы) могут накладываться дополнительные ограничения (например, <<все значения в столбце различны>>).
		\item Обычно запросы к реляционным СУБД формулируются на декларативном языке SQL
			(Structured Query Language).
	\end{itemize}
\end{frame}

\begin{frame}{Реляционная алгебра}
	Математическая модель происходящего в реляционных СУБД:
	\begin{itemize}
		\item Таблица называется \textit{отношением} (relation, отсюда relational database).
		\item Есть операции над таблицами (образующие алгебру).
			Например, <<выбрать какие-то строчки из таблицы>>.
		\item Обычно СУБД поддерживают гораздо более крутые и странные операции,
			чем в реляционной алгебре.
		\item Больше слова <<реляционная алгебра>> вам наверняка не пригодятся.
	\end{itemize}
\end{frame}

\begin{frame}{Классическая шутка}
	\begin{center}
		\LARGE
		Three database admins walked into a NoSQL bar.

		A little while later they walked out because they could not find a table.
	\end{center}
\end{frame}

\begin{frame}{Типы данных}
	Смотрим на таблицу \t{Country}:
	\begin{itemize}
		\item \t{INTEGER} "--- целое число (размер варьируется от СУБД к СУБД, как и название).
		\item \t{REAL} "--- вещественное число с плавающей запятой.
		\item \t{VARCHAR(45)} "--- строка произвольной длины, но не длиннее 45 символов\footnote{А сколько символов занимает буква <<ш>>? А в какой кодировке?}.
			Если не влезает "--- поведение зависит от СУБД.
	\end{itemize}
	Вообще говоря, конкретно в SQLite значения в столбце могут иметь тип, не совпадающий со столбцом, но об этом лучше не думать.

	За кадром остались типы:
	\begin{itemize}
		\item \t{BLOB} "--- бинарные данные любой длины.
		\item \t{TEXT} "--- строка произвольной длины без ограничений.
		\item \t{CHAR(10)} "--- строка фиксированной длины (может работать быстрее).
	\end{itemize}
\end{frame}

\begin{frame}{Прочие типы данных}
	В каждой СУБД свои типы, они могут отличаться по поведению даже просто при разных настройках внутри одной базы данных.
	Но обычно они называются приблизительно так:

	\begin{itemize}
		\item \t{DECIMAL(10, 5)} "--- вещественное число с фиксированной запятой.
		\item Вариации на тему целых чисел: \t{SMALLINT}, \t{MEDIUMINT}, ...
		\item \t{FLOAT} "--- альтернатива \t{DOUBLE}.
		\item \t{DATE}, \t{TIME}, \t{DATETIME}, \t{TIMESTAMP} и вариации для хранения дат
			\footnote{Правильная работа с датами "--- тема отдельной лекции: \href{https://habrahabr.ru/post/146109/}{1}, \href{https://habrahabr.ru/company/mailru/blog/242645/}{2}}.
	\end{itemize}

	Мораль двух слайдов: сразу сказать, какой тип <<правильный>> в конкретной ситуации нельзя,
	надо хорошо понимать предметную область и СУБД, с которой вы работаете.
	Но для своих проектов по умолчанию можно ограничиться теми типам, что проще называются.
\end{frame}

\begin{frame}{Демонстрация SQL-запросов}
	\begin{itemize}
		\item Запросы отделяются между собой точкой с запятой.
		\item Иногда интерфейс к СУБД не умеет делать несколько запросов одновременно и тогда точка с запятой не нужна.
		\item Комментарии "--- либо два дефиса в начале строки, либо \t{/* ... */}
		\item Результат запроса \t{SELECT} "--- тоже таблица, полученная из исходной.
		\item Наборы строк и столбцов в результате \t{SELECT} могут разительно отличаться от исходной.
		\item Можно фильтровать строки по условиям.
		\item Можно попросить не строки, а какую-то статистику.
		\item Если вы в SQL что-то написали, оно практически всегда либо упадёт при компиляции, либо как-то отработает на любых значениях.
	\end{itemize}
\end{frame}

\begin{frame}[t]{LIMIT и OFFSET}
	\begin{itemize}
		\item Порядок строк в таблицах и результате работы \t{SELECT} не определён.
		\item Но его можно явно задать при помощи \t{ORDER BY}, который сравнивает поля лексикографически в указанном порядке.
		\item
			Важно задавать \t{ORDER BY} так, чтобы он всегда отличал две строки.
			Этого можно добиться, только если мы знаем, какие наборы столбцов всегда отличаются.
		\item
			Другая стандартная проблема: пусть мы подгружаем бесконечную ленту новостей
			запросом \t{LIMIT~10~OFFSET~already\_loaded}.
			\pause
		\item
			Новости в ленте могут добавляться и удаляться, и номера строк даже в идеально отсортированной таблице
			постоянно меняются.
	\end{itemize}
	Мораль: не стоит надеяться на номера строк, \t{LIMIT} и \t{OFFSET} обычно возникают только при выборке <<топ-10>>.

	Правильное решение задачи с лентой:\pause <<верни топ-10 записей после такой-то новости из ленты>>.
\end{frame}

\begin{frame}{DELETE и INSERT}
	Удаление значений:
	\begin{itemize}
		\item \t{DELETE FROM Country} удалит \textbf{все} строки и не почешется.
		\item Надо писать \t{DELETE FROM Country WHERE ...}
		\item По-хорошему перед \t{DELETE} стоит сделать \t{SELECT} и посмотреть.
	\end{itemize}
	Добавление значений:
	\begin{itemize}
		\item
			После слова \t{VALUES} можно написать несколько кортежей со значениями,
			но надо знать точный порядок столбцов в таблице.
		\item На практике столбцы иногда (не часто, но иногда) меняются, добавляются и удаляются,
			поэтому всегда следует писать явно, каким столбцам что соответствует.
		\item При вставке может возникнуть ошибка, если на каком-то столбце были ограничения
	\end{itemize}
\end{frame}

\begin{frame}{Остальные запросы}
	\begin{itemize}
		\item Также бывают запросы \t{CREATE TABLE}, \t{ALTER TABLE}, \t{DROP TABLE} для работы с таблицами.
		\item Несмотря на наличие стандартов языка SQL, каждая база дополняет его по-своему,
			из-за чего получается множество несовместимых диалектов.
		\item Самые базовые команды (только что были) везде работают \textit{примерно} одинаково
			(за исключением неоднозначных ситуаций).
	\end{itemize}
\end{frame}
