\section{Вещественные числа}
\subsection{Идеи}

\begin{frame}
	\tableofcontents[currentsection,currentsubsection]
\end{frame}

\begin{frame}
	Зачем нужны вещественные числа в компьютерах?
	Почему нельзя обойтись целыми?

	\pause
	\begin{itemize}
		\item Работа с дробями и деление.
		\item Денежные единицы: копейки удобно считать сотыми частями рубля.
		\item Физические (и военные) вычисления: тригонометрия, расстояния, геокоординаты.
	\end{itemize}
\end{frame}

\begin{frame}{С фиксированной запятой}
	\begin{itemize}
		\item
			Пример: рубли.
		\item
			После запятой всегда ровно два знака: $230.40$.
		\item
			По сути те же целые числа, только надо помнить, где стоит запятая, и перемножаются чуть по-другому (со сдвигом запятой и, соответственно, обрезанием знаков).
	\end{itemize}
	Есть в некоторых базах данных, используются как раз для хранения количества денег.

	Плюсы:
	\begin{itemize}
		\item Абсолютная точность, кроме, иногда, умножения и деления.
		\item Простые и предсказуемые операции.
		\item Простое описание допустимых значений.
	\end{itemize}
\end{frame}

\begin{frame}{Минусы}
	\begin{itemize}
		\item
			Надо заранее знать, сколько знаков потребуется.
		\item
			Если может требоваться разное число знаков в разных местах "--- надо брать разные типы данных и конвертировать.
		\item
			Соответственно, нужен разный код, если есть вычисления и с <<большими>> числами, и с <<маленькими>>.
		\item
			Не реализовать аппаратно, потому что неясно, сколько знаков отбрасывать при умножении;
			реализовывать много типов сложно.
	\end{itemize}
\end{frame}

\begin{frame}{С плавающей запятой}
	\begin{itemize}
		\item
			Обобщение числа с фиксированной запятой.
		\item
			Храним отдельно число и отдельно "--- сколько у нас знаков идёт после запятой, а сколько "--- до.
		\item
			Умножение и деление остались примерно такими же по сложности, а вот сложение и вычитание усложнились (надо сравнивать порядок чисел).
		\item
			Теперь можно делать вычисления с числами любого порядка, и будем знать порядок ответа и первые сколько-то цифр.
	\end{itemize}
	Плюсы:
	\begin{itemize}
		\item
			Одинаково хорошо работаем и с маленькими, и с большими числами.
		\item
			Относительная погрешность вычислений сохраняется.
	\end{itemize}
\end{frame}

\subsection{Детали}
\begin{frame}{Первая попытка}
	Пусть храним числа так:
	\begin{gather*}
		x = a \cdot 10^{b} \\
		-32768 \le a, b \le 32767
	\end{gather*}
	Тут $a$ "--- \textit{мантисса}, $b$ "--- \textit{экспонента}.

	Например:
	\begin{align*}
		12.3 &= 123 \cdot 10^{-1} \\
		231000 &= 231 \cdot 10^3 \\
		12.3 \cdot 231000 &= 123 \cdot 10^{-1} \cdot 231 \cdot 10^3 = (123 \cdot 231) \cdot 10^{-1+3} = 28413 \cdot 10^2 \\
		12.3 + 231000 &= 123 \cdot 10^{-1} + 231 \cdot 10^3 = (123 + \underbrace{2310000}_{>>32767}) \cdot 10^{-1}
	\end{align*}
\end{frame}

\begin{frame}{Трудности с десятичной системой}
	\begin{itemize}
		\item При сложении у нас легко может произойти переполнение типа.
		\item Можно пытаться оставлять только самые значащие цифры.
		\item Но в общем случае надо домножать на большую степень десятки.
		\item Как это делать без очень больших чисел и без домножения на десятку каждый раз "--- неясно.
		\item Храним-то всё в двоичной системе, а там от умножения на десять меняется всё число.
	\end{itemize}
\end{frame}

\begin{frame}{Решение проблемы}
	Храним числа так:
	\begin{gather*}
		x = a \cdot \textbf{2}^b \\
		-32768 \le a, b \le 32767
	\end{gather*}
	\begin{itemize}
		\item Теперь стало легко и складывать, и перемножать, так как при домножении на двойку легко понять, сколько цифр не нужны.
		\item Можно реализовать в железе.
		\item
			Проблемы с тем, что нет чёткого соответствия между десятичными знаками после запятой и двоичными,
			нет точности:
	\end{itemize}
	\begin{align*}
		0.75_{10} &= {0.11}_{2} \\
		7 \cdot 10^{-1} + 5 \cdot 10^{-2} &= 2^{-1} + 2^{-2} \\
		0.1_{10} &= {0.000110011001100110011001101\dots}_{2} \\
		10^{-1} &= 2^{-4} + 2^{-5} + 2^{-7} + 2^{-8} + \dots \\
	\end{align*}
\end{frame}

\begin{frame}[fragile]{Упражнение}
	\begin{itemize}
		\item
			Введите в Python:
\begin{minted}{python}
x=0.1
print(x)
print(format(x, ".1000f"))
\end{minted}
		\item
			Убедитесь, что вы не получили \t{0.1}
		\item
			Найдите, на какую степень двойки надо домножить $x$, чтобы он стал целым.
			По сути "--- грубое приближение числа знаков в мантиссе.
	\end{itemize}
	\pause
	Ответ: на $2^{55}$.
	Из этого можно сделать вывод, что в мантиссе порядка $55$ знаков.
\end{frame}
