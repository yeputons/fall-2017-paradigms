\subsection{IEEE 754}
\begin{frame}
	\tableofcontents[currentsection,currentsubsection]
\end{frame}

\begin{frame}{Что такое IEEE 754}
	\begin{itemize}
		\item
			IEEE 754 "--- это стандарт хранения и обработки вещественных чисел с плавающей запятой, который используется почти везде.
		\item
			Но не вообще везде.
		\item
			Определяет несколько типов данных с разными размерами мантисс и экспонент: single precision, double precision, и ещё несколько.
		\item
			Достаточно разумно определяет операции для всех аргументов и решает некоторые проблемы.
		\item
			Из-за этого сложнее, чем идея с предыдущих слайдов.
		\item
			Есть $\pm \infty$, есть \t{NaN} (Not a Number, получается при делении нуля на ноль).
		\item
			В Python используется double-precision (тип \t{float}).
		\item
			В C++/Java есть как single-precision (\t{float}), так и double-precision (\t{double}).
	\end{itemize}
\end{frame}

\begin{frame}{Формат single-precision}
	Основная масса "--- \textit{нормализованные числа}:
	\begin{center}
		\begin{tabular}{c|c|c}
			\multicolumn{3}{c}{Биты} \\
			31 & 30-23 & 22-0 \\\hline
			знак ($s$) & экспонента ($e$) & мантисса ($m$) \\
		\end{tabular}
	\end{center}
	\begin{enumerate}
		\item
			Если $s=0$, то число положительное, иначе отрицательное.
		\item
			Предполагается, что экспонента подобрана так, чтобы перед запятой был ровно один знак "--- единица.
		\item
			Мантисса хранит все знаки \textit{строго после} этой единицы.
		\item
			Если $e=0$, то у нас число вида \t{1.1001010010} в двоичной записи (до запятой "--- ровно одна единица).
		\item
			Итоговая формула (для \textit{нормализованных} чисел):
			\[ x = (-1)^s \cdot 2^{e} \cdot (1 + m \cdot 2^{-23}) \]
	\end{enumerate}
\end{frame}

\begin{frame}{Хранение экспоненты}
	Экспонента хранится как беззнаковое число со сдвигом на 127:
	\begin{center}
		\begin{tabular}{r|l}
			Двоичное представление & $e$ \\\hline
			\t{0000 0000} & -127 \\
			\t{0000 0001} & -126 \\
			\vdots & \vdots \\
			\t{0111 1110} & -1 \\
			\t{0111 1111} & 0 \\
			\t{1000 0000} & 1 \\
			\vdots & \vdots \\
			\t{1111 1110} & 127 \\
			\t{1111 1111} & 128 \\
		\end{tabular}
	\end{center}
	Обратите внимание, что отрезок чисел "--- от $-127$ до 128, а не от $-128$ до $127$ (как в дополнительном коде).
\end{frame}

\begin{frame}{Пример}
	\[
		x = -13.75_{10} = \frac{-220}{16} = -1101.1100_2
	\]
	Подбираем экспоненту так, чтобы слева получилась ровно одна единица:
	\begin{align*}
		x &= -1.\underbrace{1011100_2}_{m'=184_{10}} \cdot 2^3 = \quad e=3 \\
		  &= -1.\underbrace{10111000000000000000000_2}_{m} \cdot 2^3
	\end{align*}
	Так как в $m$ предполагается 23 значащих знака (а у нас в $m'$ только 7), надо дописать \textit{справа} нулей.
	Итого:
	\begin{center}
		\begin{tabular}{c|c|c}
			\multicolumn{3}{c}{Биты} \\
			31 & 30-23 & 22-0 \\\hline
			\t{1} & $\underbrace{\t{100~0001~0}}_{e+127}$ & $\underbrace{\t{\textbf{101~110}0~0000~0000~0000~0000}}_{m}$ \\
		\end{tabular}
	\end{center}	
\end{frame}

\begin{frame}{Проблемы с аксиомами}
	Какое наименьшее нормализованное число можно представить в таком формате?
	Очевидно, при минимальной экспоненте (-127) и мантиссе.
	Тогда самые маленькие числа таковы:
	\begin{align*}
		x &= 2^{-127} \cdot 1 \\
		y &= 2^{-127} \cdot (1 + 1 \cdot 2^{-23}) \\
		z &= 2^{-127} \cdot (1 + 2 \cdot 2^{-23}) \\
		& \text{посчитаем что-нибудь:} \\
		y - x &= 2^{-127} \cdot (1 + 1 \cdot 2^{-23} - 1) = 2^{-127} \cdot 1 \cdot 2^{-23} = 2^{-150}
	\end{align*}
	Вопрос: как хранить $2^{-150}$?
	\begin{itemize}
		\item
			Округлять к $2^{-127}$ странно: это далеко; тогда бы получили, что $x-y=x$, но $x\neq x + y$.
		\item
			Округлять к нулю тоже странно: $x \neq y$, но $x - y = 0$.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Денормализованные числа}
	\begin{itemize}
		\item 
			Вблизи нуля добавили \textit{денормализованные числа}, чтобы повысить точность и избежать подобных проблем с аксиомами.
		\item
			Теперь стандарт гарантирует, что $x - y = 0 \iff x = y$.
		\item
			Денормализованное число "--- это число с минимально возможной экспонентой, у которого отсутствует единица перед запятой:
			\begin{center}
				\begin{tabular}{r|r}
					Нормализованные   & $\t{\textbf{1}.\overbrace {0010011}^{m}} \cdot 2^{e=4}$ \\\hline
					Денормализованные & $\t{\textbf{0}.\underbrace{10010011}_{m}} \cdot 2^{e=5}$ \\
				\end{tabular}
			\end{center}
		\item
			Это просто $2^{23}$ чисел, равномерно распределённых от 0 до минимального нормализованного.
		\item
			Всё равно можно получить underflow:
\begin{minted}{python}
x=2**(-1074)
print(x, x / 2 * 2)
\end{minted}
	\end{itemize}
\end{frame}

\begin{frame}{Формат}
	Скажем, что если экспонента состоит из нулей, то у нас денормализованное число:
	\begin{center}
		\begin{tabular}{r|c|c|c}
			\multicolumn{3}{c}{Биты} \\
			31 & 30-23 & 22-0 \\\hline
			знак ($s$) & нули & мантисса $m$ \\
		\end{tabular}
	\end{center}
	Тут мы уже считаем, что мантисса записана целиком, включая старшую единицу.
	Формула:
	\[
		x = (-1)^s \cdot 2^{-12\textbf{6}} \cdot m \cdot 2^{-23}
	\]
	Тогда денормализованные числа лежат в диапазоне:
	\[
		2^{-126} \cdot 2^{-23} \le x \le 2^{-126} \cdot (2^{23}-1) \cdot2^{-23}
	\]
	А нормализованные "--- в таком:
	\[
		2^{-126} \cdot 1 \le x
	\]
\end{frame}

\begin{frame}
	\begin{center}
		\includegraphics[scale=0.75]{what-are-you-doing.jpg}
	\end{center}
\end{frame}

\begin{frame}{Все особенности IEEE-754}
	Числа, доступные в IEEE 754 одинарной точности:
	\begin{center}
		\begin{tabular}{r|c|c|c}
			\multicolumn{3}{c}{Биты} & \\
			31 & 30-23 & 22-0 & Значение \\\hline
			\t{0} & \t{111 1111 1} & \t{000 0000 0000 0000 0000 0000} & $+\infty $\\
			\t{1} & \t{111 1111 1} & \t{000 0000 0000 0000 0000 0000} & $-\infty $\\
			\t{?} & \t{111 1111 1} & не нули                          & \t{NaN} \\
			\t{0} & \t{000 0000 0} & \t{000 0000 0000 0000 0000 0000} & $+0$ \\
			\t{1} & \t{000 0000 0} & \t{000 0000 0000 0000 0000 0000} & $-0$ \\
			\t{?} & \t{000 0000 0} & не нули                          & д. число \\
			\t{?} & что угодно     & что угодно                       & н. число \\
		\end{tabular}
	\end{center}	
\end{frame}

\begin{frame}{Упражнение}
	\begin{enumerate}
		\item
			Введите несколько простых десятичных дробей в Python и попробуйте методы \t{float.as\_integer\_ratio()} и \t{float.hex()}.
		\item
			Составьте таблицу сравнения для \t{0}, \t{+0}, \t{-0} на Python: кто кому равен, кто кого меньше.
		\item
			Добавьте в эту таблицу сравнения \t{NaN}.
		\item
			На C++/Python составьте таблицу уможнения для $\pm0$, $\pm 1$, $\pm \infty$ и \t{NaN}.
		\item
			На C++ составьте таблицу деления для этих же чисел (на Python некоторые операции вызывают исключение
	\end{enumerate}
\end{frame}
