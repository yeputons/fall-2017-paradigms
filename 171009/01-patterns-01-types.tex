\section{Паттерны}
\subsection{Классификация}

\begin{frame}
	\tableofcontents[currentsection,currentsubsection]
\end{frame}

\begin{frame}{Что такое паттерн}
	\begin{itemize}
		\item
			\textit{Паттерн} (или \textit{шаблон проектирования}) "--- это какая-то стандартная конструкция для решения каких-то архитектурных задач.
		\item
			Другими словами: какие абстракции и интерфейсы полезно использовать в каких ситуациях.
		\item
			Некоторые паттерны идут <<от капитана>> (можно назвать <<очевидным здравым смыслом>>), некоторые более хитры.
		\item
			Часто может казаться, что без паттерна легко обойтись, потому что в программе нужен очень частный случай.
			Зато если требования поменяются "--- можно огрести.
		\item
			Легко перегнуть палку: <<абстрактные фабрики абстрактных фабрик>> и прочие радости.
		\item
			Мы пройдёмся очень поверхностно.
			Вообще есть большие книжки (от <<банды четырёх>>) и курсы, где про это рассказывают.
		\item
			Часто называются по-английски.
	\end{itemize}
\end{frame}

\begin{frame}{Поведенческие шаблоны}
	Рассказывают, как объекты могут между собой взаимодействовать.

	Примеры:
	\begin{itemize}
		\item
			\textit{Итератор} (\textit{Iterator}): уже познакомились.
			Позволяет итерироваться по произвольным коллекциям.
		\item
			\textit{Наблюдатель} (\textit{Observer}): если некоторые объекты могут рассылать события, а некоторые
			должны на них реагировать, то можно создать интерфейс <<наблюдатель за событием>> и вспомогательные классы
			для рассылки событий.
			Тогда наблюдателю надо лишь добавиться в нужный список, а инициатору события "--- вызвать метод <<оповести наблюдателей из списка>>.
		\item
			\textit{Посетитель} (\textit{Visitor}): будет в домашнем задании, разберём позже.
	\end{itemize}
\end{frame}

\begin{frame}{Структурные шаблоны}
	Рассказывают, как компоновать между собой классы и объекты.

	Примеры:
	\begin{itemize}
		\item
			\textit{Адаптер} (\textit{Adapter}): если у нас есть класс с интерфейсом $A$, а нам нужно передать куда-то класс с другим интерфейсом $B$
			(другие название), то можно создать класс, который просто будет конвертировать вызовы интерфейса $B$ в вызовы $A$.
		\item
			\textit{Компоновщик} (\textit{Composite}): если нам часто нужно совершать одинаковые операции над разными объектами (например, отрисовать элементы
			окна на экране), то их можно объединить в коллекцию, которая предоставляет общий интерфейс для этих объектов.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Порождающие шаблоны}
	Рассказывают, как создавать и компоновать объекты в коде.
	Примеры:
	\begin{itemize}
		\item
			\textit{Строитель} (\textit{Builder}): если есть объект с очень сложным конструктором, то можно создать
			промежуточный объект, который будет <<накапливать>> в себе параметры конструктора, а потом создаст объект:
\begin{minted}{python}
def create_button():
    builder = ButtonBuilder()
    builder.set_text("Кнопка")
    if some_complex_condition(): builder.set_disabled()
    return builder.build()
\end{minted}
		\item
			\textit{Абстрактная фабрика}  (\textit{Abstract factory}): если объекты постоянно требуют какого-то включения в систему, то можно
			не вызывать конструкторы напрямую, а выделить кусок системы, который будет
			правильным образом конструировать объекты.
	\end{itemize}
\end{frame}
